from datetime import datetime
import os

# ***********************************************************************************
def gaussian_write_optm(ffullname, dict_elements, coords,
                        gaussian_keywords, chkfullpath="./gauss.chk",
                        nproc=1, mem=None,
                        title="Input file generated by CHIRIPA",
                        charge=0, multiplicity=1):

    """
    Write an input to perform a calculation in Gaussian16.

    ``Parameters``:
        * **path_to_dftb_program**
        * **ffullname** (type: str) --> Full path to write the input file (fullpath+"dftb_in.hsd").\
         The input name in dftbplus(v.19.1) must be "dftb_in.hsd".
        * **dict_elements** (type: dictionary) --> A dictionary d[index] = 'name_of_atom'.\
         Example: {0:'C', 1:'H', ...}. It must have natoms elements
        * **coords** (type: ndarray[natoms,3]) --> Atom coordinates
        * **gaussian_keywords** (type:dict) --> A dict containing keywords for gaussian
        * **chkfullpath** (type: str, default="./gauss.chk") --> Path to the chk file
        * **nproc** (type: integer, default=4) --> Number of processes to be used in Gaussian
        * **mem** (type: str, default='8Gb') --> Memory to be used by gaussian
        * **title** (type: str, default='Inpu...') --> Title of the gaussian job
        * **charge** (type: integer, default=0) --> Total charge
        * **multiplicity** (type: integer, default=1) --> Multiplicity spin
    """

    # Check input parameters ******
    if coords.shape[0] != len(dict_elements):
        print("Warning!!!. The {} cannot be written. "
              "Number of atoms in element list and number of coordinates must be the same".format(ffullname))
        return False


    with open(ffullname,'w') as fin:

        # Write chk line
        fin.writelines("%chk={}\n".format(chkfullpath))

        # Write nproc line
        fin.writelines("%nproc={}\n".format(nproc))

        # Write mem line
        if not gaussian_keywords['mem_mb'] is None:
            fin.writelines("%mem={}Mb\n".format(gaussian_keywords['mem_mb']))

        # Write keyword line
        if gaussian_keywords['qm_task'].lower() == 'energy':
            line = "#p {} {} {}".format(gaussian_keywords['basis_set'],
                                        gaussian_keywords['qm_method'],
                                        gaussian_keywords['other_keys'])
        else:
            line = "#p {} {} {} {}".format(gaussian_keywords['qm_task'],
                                           gaussian_keywords['basis_set'],
                                           gaussian_keywords['qm_method'],
                                           gaussian_keywords['other_keys'])

        fin.writelines(line)
        if not line[-1] == "\n":
            fin.writelines("\n\n")
        else:
            fin.writelines("\n")

        # Write title line
        d = datetime.now().strftime("%d-%b-%Y %H:%M:%S")
        fin.writelines(title+" ("+d+")")
        if not title[-1] == "\n":
            fin.writelines("\n\n")
        else:
            fin.writelines("\n")

        # Write title charge and multiplicity
        fin.writelines("{} {}\n".format(charge, multiplicity))
        # Coordinates ******
        index = 1
        for icoord in coords:
            iel = dict_elements[index-1]
            fin.writelines("{0:s} {1:>12.6f} {2:>12.6f} {3:>12.6f} \n".
                            format(iel, icoord[0], icoord[1], icoord[2]))
            index += 1
        fin.writelines("\n")

    return True

# ***********************************************************************************
def gaussian_basic_slurm_script(maindir, inputname,
                                g16pathexe,
                                partition,
                                nodelist=None,
                                jobname=None,
                                fnamescript="send.sh",
                                numbernodes=1,
                                cpuspertask=1, memory=500):

    """
    Write a script to run gaussian 16 in server with slurm queue system

    ``Parameters``::
        * **fnamescript** (type str) : Name of the script to run with sbatch
        * **g16path** (type str) : Path to the gaussian executable
        * **inputname** (type str) : name of the input file to run Gaussian
        * **partition** (type str) : name of the partition in the Slurm system
        * **nodelist** (type list) : list of nodes to run the job
        * **numbernodes** (type integer) : Number of nodes
        * **cpuspertask** (type integer) : Number of cores within the nodes
        * **memory** (type integer): Memory in Megabytes
        * **jobname** (type str) : Name in the job list

    ``Returns``::
        * **None**

    """

    if jobname is None:
        jobname = "g16_chiripa"

    with open(maindir+"/"+fnamescript, 'w') as f:

        f.writelines("#!/bin/bash\n")
        if not partition is None:
            f.writelines("#SBATCH --partition={}\n".format(partition))
        if not nodelist is None:
            l = ""
            for item in nodelist:
                l+=item+", "
            l = l[:-1]
            f.writelines("#SBATCH --exclude=\"{}\"\n".format(l))
        f.writelines("#SBATCH -N {}\n".format(numbernodes))
        f.writelines("#SBATCH --cpus-per-task={}\n".format(cpuspertask))
        if not memory is None:
            f.writelines("#SBATCH --mem={}M\n".format(memory))
        f.writelines("#SBATCH --job-name={}\n".format(jobname))
        g16path, exe = os.path.split(g16pathexe)
        f.writelines("\ng16legacy_root={}\n".format(g16path))
        f.writelines("GAUSS_SCRDIR=\"$TMPDIR\"\n")
        f.writelines("source $g16legacy_root/bsd/g16.profile\n")
        f.writelines("export g16legacy_root GAUSS_SCRDIR\n")
        f.writelines("$g16legacy_root/{} {}\n".format(exe, inputname))

# ***********************************************************************************
def gaussian_basic_local_script(maindir, inputname,
                                qm_path_exe, scratchdir,
                                fnamescript="send.sh"):
    g16path= os.path.split(qm_path_exe)[0]
    g16exe = qm_path_exe

    if maindir[-1] != "/":
        localfile = maindir + "/" + fnamescript
    else:
        localfile = maindir + fnamescript

    l = '#!/bin/bash\n'
    l +='echo \"Job Started!!! `date`\" >time.dat\n'

    l += '\n'
    l += '# Environment variables Gaussian16\n'
    l += 'export GAUSS_EXEDIR={}:{}\n'.format(g16path, g16path+"/bsd")
    l += 'export GAUSS_SCRDIR={}\n'.format(scratchdir)
    l += '\n'
    l += '    inp=`ls {}.com`\n'.format(inputname)
    l += '    out=$inp.log\n'
    l += '    {} <$inp >$out\n'.format(qm_path_exe)
    l += '    rm -f *.chk\n'
    l +='echo \"Job Done!!! `date`\" >>time.dat\n'
    txt=l

    with open(localfile, 'w') as f:
        f.writelines(txt)

# ***********************************************************************************
# def gaussian_basic_local_script(remotedir, qm_path_exe, scratchdir):
#
#     """full_send.sh
#
#     Args:
#         localdir:
#
#     Returns:
#
#     """
#     g16path= os.path.split(qm_path_exe)[0]
#     g16exe = qm_path_exe
#     localfile = remotedir+"full_send.sh"
#
#     l = '#!/bin/bash\n'
#     l += '\n'
#     l += '# Environment variables Gaussian16\n'
#     l += 'export GAUSS_EXEDIR={}:{}\n'.format(g16path, g16path+"/bsd")
#     l += 'export GAUSS_SCRDIR={}\n'.format(scratchdir)
#     l += '\n'
#     l += 'TOTALJOBS=`ls -ld *_[0-9]*/*_[0-9]* |wc -l`\n'
#     l += '\n'
#     l += 'for idir in `ls -d *_[0-9]*/*_[0-9]*`; do\n'
#     l += '\n'
#     l += '    cd $idir\n'
#     l += '\n'
#     l += '    if [[ ! -e ../jobs.txt ]]; then\n'
#     l += '        echo -n >../jobs.txt\n'
#     l += '    fi\n'
#     l += '    inp=`ls *.com`\n'
#     l += '    out=$inp.log\n'
#     l += '\n'
#     l += '    b=`basename $idir`\n'
#     l += '    echo "$inp $b $out" >>../jobs.txt\n'
#     l += '`   {} <$inp >$out\n`\n'.format(g16exe)
#     l += '    rm *.chk\n'
#     l += '    cd ../..\n'
#     l += 'done\n'
#     txt=l
#
#     with open(localfile, 'w') as f:
#         f.writelines(txt)